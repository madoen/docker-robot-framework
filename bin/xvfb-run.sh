#!/bin/sh

# Copyright (c) 2017 The Smithsonian Astrophysical Observatory
# Copyright (c) 2017 Diab Jerius

# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../xorg-server/xvfb-run.sh
# Copyright (C) 2005 The T2 SDE Project
# Copyright (C) XXXX - 2005 Debian
# 
# More information can be found in the files COPYING and README.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License. A copy of the
# GNU General Public License can be found in the file COPYING.
# --- T2-COPYRIGHT-NOTE-END ---

# $Id$
# from: http://necrotic.deadbeast.net/xsf/XFree86/trunk/debian/local/xvfb-run

# This script starts an instance of Xvfb, the "fake" X server, runs a command
# with that server available, and kills the X server when done.  The return
# value of the command becomes the return value of this script.
#
# If anyone is using this to build a Debian package, make sure the package
# Build-Depends on xvfb, xauth, and coreutils.

set -e

VERSION="@VERSION@"
PROGNAME=xvfb-run
SERVERNUM=99
AUTHFILE=
ERRORFILE=/dev/null
XVFBARGS="-screen 0 640x480x8"
LISTENTCP="-nolisten tcp"
XAUTHPROTO=.
SERVER_TIMEOUT=5
COMMAND_KILL_AFTER_TIMEOUT=

# Query the terminal to establish a default number of columns to use for
# displaying messages to the user.  This is used only as a fallback in the event
# the COLUMNS variable is not set.  ($COLUMNS can react to SIGWINCH while the
# script is running, and this cannot, only being calculated once.)
DEFCOLUMNS=$(stty size 2>/dev/null | awk '{print $2}') || true
if ! expr "$DEFCOLUMNS" : "[[:digit:]]\+$" >/dev/null 2>&1; then
    DEFCOLUMNS=80
fi

# Display a message, wrapping lines at the terminal width.
message () {
    # echo "$PROGNAME: $*" | fmt -t -w ${COLUMNS:-$DEFCOLUMNS}
    echo "$PROGNAME: $*"
}

# Display an error message.
error () {
    message "error: $*" >&2
}

# Display a usage message.
usage () {
    if [ -n "$*" ]; then
        message "usage error: $*"
    fi
    cat <<EOF
Usage: $PROGNAME [OPTION ...] COMMAND
Run COMMAND (usually an X client) in a virtual X server environment.
Options:
-a        --auto-servernum          try to get a free server number, starting at
                                    --server-num (deprecated, use --auto-display
                                    instead)
-d        --auto-display            use the X server to find a display number
                                    automatically
-e FILE   --error-file=FILE         file used to store xauth errors and Xvfb
                                    output (default: $ERRORFILE)
-f FILE   --auth-file=FILE          file used to store auth cookie
                                    (default: ./.Xauthority)
-h        --help                    display this usage message and exit
-n NUM    --server-num=NUM          server number to use (default: $SERVERNUM)
-l        --listen-tcp              enable TCP port listening in the X server
-p PROTO  --xauth-protocol=PROTO    X authority protocol name to use
                                    (default: xauth command's default)
-s ARGS   --server-args=ARGS        arguments (other than server number and
                                    "-nolisten tcp") to pass to the Xvfb server
                                    (default: "$XVFBARGS")
          --server-timeout=TIME     seconds to wait for server to respond in
                                    --auto-display mode (default: $SERVER_TIMEOUT)
-t TIME   --command-timeout=TIME    kill COMMAND if it runs for longer than TIME.
                                    see timeout(1) for units
          --command-kill-after-timeout=TIME
                                    send a SIGKILL to the command if doesn't
                                    exit after being killed for TIME.
                                    see timeout(1) for units
          --version                 output version and exit
EOF
}

# Find a free server number by looking at .X*-lock files in /tmp.
find_free_servernum() {
    # Sadly, the "local" keyword is not POSIX.  Leave the next line commented in
    # the hope Debian Policy eventually changes to allow it in /bin/sh scripts
    # anyway.
    #local i

    i=$SERVERNUM
    while [ -f /tmp/.X$i-lock ]; do
        i=$(($i + 1))
    done
    echo $i
}

# Clean up files
clean_up() {
    if [ -e "$AUTHFILE" ]; then
        XAUTHORITY=$AUTHFILE xauth remove ":$SERVERNUM" >>"$ERRORFILE" 2>&1
    fi
    if [ -n "$XVFB_RUN_TMPDIR" ]; then
        if ! rm -r "$XVFB_RUN_TMPDIR"; then
            error "problem while cleaning up temporary directory"
            exit 5
        fi
    fi
    if [ -n "$XVFBPID" ]; then
        kill "$XVFBPID" >>"$ERRORFILE" 2>&1
    fi
}

# Parse the command line.
ARGS=$(getopt --options +ade:f:hn:lp:s:w:t:                             \
              --long auto-servernum,error-file:,auth-file:              \
              --long help,server-num:,listen-tcp,xauth-protocol:        \
              --long server-args:,wait:,auto-display,debug,version      \
              --long command-timeout:                                   \
              --long command-kill-after-timeout:                        \
              --long server-timeout:                                    \
              --name "$PROGNAME" -- "$@")
GETOPT_STATUS=$?

if [ $GETOPT_STATUS -ne 0 ]; then
    error "internal error; getopt exited with status $GETOPT_STATUS"
    exit 6
fi

eval set -- "$ARGS"

while :; do
    case "$1" in
        -a|--auto-servernum) SERVERNUM=$(find_free_servernum)  AUTONUM="yes";;
        -d|--auto-display) AUTO_DISPLAY=1 ;;
        -e|--error-file) ERRORFILE="$2"; shift ;;
        -f|--auth-file) AUTHFILE="$2"; shift ;;
        -h|--help) SHOWHELP="yes" ;;
        -n|--server-num) SERVERNUM="$2"; shift ;;
        -l|--listen-tcp) LISTENTCP="" ;;
        -p|--xauth-protocol) XAUTHPROTO="$2"; shift ;;
        -s|--server-args) XVFBARGS="$2"; shift ;;
        -t|--command-timeout) COMMAND_TIMEOUT="$2"; shift ;;
        --command-kill-after-timeout) COMMAND_KILL_AFTER_TIMEOUT="$2"; shift ;;
        --server-timeout) SERVER_TIMEOUT="$2"; shift ;;
        -w|--wait) ;;
        --version) echo $PROGNAME $VERSION; exit 0 ;;
        --debug) set -x ;;              
        --) shift; break ;;
        *) error "internal error; getopt permitted \"$1\" unexpectedly"
           exit 6
           ;;
    esac
    shift
done

if [ "$SHOWHELP" ]; then
    usage
    exit 0
fi

if [ -z "$*" ]; then
    usage "need a command to run" >&2
    exit 2
fi

if ! command -v xauth >/dev/null; then
    error "xauth command not found"
    exit 3
fi

if [ -n "$AUTONUM" -a -n "$AUTO_DISPLAY" ]; then
    error "do not specify both --auto-servernum and --auto-display"
    exit 1
fi

# tidy up after ourselves
trap clean_up EXIT

# Set up the temp dir for the X authorization file and other things
# XVFB_RUN_TMPDIR="$(mktemp --directory --tmpdir $PROGNAME.XXXXXX)"
XVFB_RUN_TMPDIR="$(mktemp -d -t $PROGNAME.XXXXXX)"

# If the user did not specify an X authorization file to use, create one.
if [ -z "$AUTHFILE" ]; then
    AUTHFILE=$(mktemp -p "$XVFB_RUN_TMPDIR" Xauthority.XXXXXX)
fi

# Start Xvfb.
MCOOKIE=$(mcookie)

if [ -n "$AUTONUM" ]; then

    trap : USR1

    tries=10
    while [ $tries -gt 0 ]; do
        tries=$(( $tries - 1 ))

        # handle SIGUSR1 so Xvfb knows to send a signal when it's ready to accept
        # connections
        (trap '' USR1; exec Xvfb ":$SERVERNUM" $XVFBARGS $LISTENTCP -auth $AUTHFILE >>"$ERRORFILE" 2>&1) &
        XVFBPID=$!

        wait || :
        if kill -0 $XVFBPID 2>/dev/null; then
            break
        fi

        # The display is in use so try another one (if '-a' was specified).
        XVFBPID=
        SERVERNUM=$((SERVERNUM + 1))
        SERVERNUM=$(find_free_servernum)
    done

    if [ -z "$XVFBPID" ]; then
        error "Xvfb failed to start" >&2
        XVFBPID=
        exit 7
    fi

elif [ -n "$AUTO_DISPLAY" ]; then

  # New style using Xvfb to provide a free display
  FIFO=$(mktemp -u -p "$XVFB_RUN_TMPDIR" fifo.XXXXXX)

  mkfifo $FIFO
  
  # USR1 doesn't seem to be sent by Xvfb if it's passed -displayfd, so
  # can't wait for it as is done above
  Xvfb -displayfd 9 $XVFBARGS $LISTENTCP -auth $AUTHFILE >>"$ERRORFILE" 2>&1 9>$FIFO &
  XVFBPID=$!

  if ! kill -0 $XVFBPID 2>/dev/null; then
      error "Xvfb failed to start" >&2
      XVFBPID=
      exit 7
  fi

  # retrieve the server id from the server using the approach detailed in 
  # https://unix.stackexchange.com/a/18711:
  #
  #    foo=`sh -ic 'exec 3>&1 2>/dev/null; { cat 1>&3; kill 0; } | { sleep 2; kill 0; }'`
  #
  # However, this will hang if run without a controlling terminal
  # (e.g. if xvfb-run is executed by GNU parallel).  In that case the
  # sub process' shell gets a SIGTTIN signal and stops.
  #
  # Removing the -i option avoids that problem, but then the shell
  # doesn't create its own process group, so kill 0 kills both the sub
  # shell and *this* shell as well.  The solution to that is to make
  # the subshell an process leader in its own process group using setsid.

  set +e
  # dash doesn't seem to pay attention to the redirect of fd 2 in the
  # subshell. redirecting our stderr does the trick.
  exec 4>&2 2>>"$ERRORFILE"
  SERVERNUM=$(exec 3>&1 2>>"$ERRORFILE" setsid sh -c "{ read < $FIFO SERVERNUM ; echo \$SERVERNUM >&3; kill 0; } | { sleep $SERVER_TIMEOUT; kill 0; }")
  exec 2>&4
  set -e

  if [ -z "$SERVERNUM" ]; then
      error "unable to get servernum from server"
      exit 7
  fi

else

    trap : USR1
    # Old style using a pre-computed SERVERNUM
    ( trap '' USR1; exec Xvfb ":$SERVERNUM" $XVFBARGS $LISTENTCP -auth $AUTHFILE >>"$ERRORFILE" 2>&1 )&
    XVFBPID=$!

    wait || :
    if ! kill -0 $XVFBPID 2>/dev/null; then
        error "Xvfb failed to start" >&2
        XVFBPID=
        exit 7
    fi

fi

XAUTHORITY=$AUTHFILE xauth source - << EOF >>"$ERRORFILE" 2>&1
add :$SERVERNUM $XAUTHPROTO $MCOOKIE
EOF


COMMAND=$1
shift;

if [ -n "$COMMAND_TIMEOUT" ]; then
    if [ -n "$COMMAND_KILL_AFTER_TIMEOUT" ]; then
       COMMAND="timeout --kill-after=$COMMAND_KILL_AFTER_TIMEOUT $COMMAND_TIMEOUT $COMMAND"
    else
       COMMAND="timeout $COMMAND_TIMEOUT $COMMAND"
    fi
fi

# Start the command and save its exit status.
set +e
DISPLAY=:$SERVERNUM XAUTHORITY=$AUTHFILE $COMMAND "$@"
RETVAL=$?
set -e

# Return the executed command's exit status.
exit $RETVAL

# vim:set ai et sts=4 sw=4 tw=80:
